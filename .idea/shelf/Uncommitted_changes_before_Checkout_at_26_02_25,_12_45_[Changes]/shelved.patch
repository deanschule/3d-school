Index: frontend/index.html
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><!DOCTYPE html>\n<html lang=\"en\">\n\t<head>\n\t\t<title>See your school</title>\n\t\t<meta charset=utf-8 />\n\t\t<meta name=\"viewport\" content=\"width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0\">\n\t\t<link type=\"text/css\" rel=\"stylesheet\" href=\"main.css\">\n\t</head>\n\t<body>\n\n\t\t<!--\n\t\t<div id=\"info\">\n\t\t\tMOUSE to look around<br/>\n\t\t\tWASD to move and SPACE to jump\n\t\t</div>-->\n\t\t<div id=\"info\">\n\t\t\t<div >\n\t\t\t\t<div id=\"content\">\n\t\t\t\t\t<h1>Welcome</h1>\n\t\t\t\t\t<span>WSAD to move / Mouse to look around</span>\n\t\t\t\t\t<span>Click to Start</span>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\n\n\t\t<div id=\"container\"></div>\n\n\t\t<script type=\"importmap\">\n\t\t\t{\n\t\t\t\t\"imports\": {\n\t\t\t\t\t\"three\": \"../build/three.module.js\",\n\t\t\t\t\t\"three/addons/\": \"./jsm/\"\n\t\t\t\t}\n\t\t\t}\n\t\t</script>\n\n\t\t<script type=\"module\">\n\nimport * as THREE from 'three';\n\nimport Stats from 'three/addons/libs/stats.module.js';\n\nimport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\nimport { Octree } from 'three/addons/math/Octree.js';\nimport { OctreeHelper } from 'three/addons/helpers/OctreeHelper.js';\n\nimport { Capsule } from 'three/addons/math/Capsule.js';\n\n//import { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n//import Box from './Box.js';\n//import Player from './Player.js';\n\n\t\t\tconst clock = new THREE.Clock();\n\n\t\t\tconst scene = new THREE.Scene();\n\t\t\tscene.background = new THREE.Color( 0x88ccee );\n\t\t\tscene.fog = new THREE.Fog( 0x88ccee, 0, 50 );\n\n\t\t\tconst camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 1000 );\n\t\t\tcamera.rotation.order = 'YXZ';\n\n\t\t\tconst fillLight1 = new THREE.HemisphereLight( 0x8dc1de, 0x00668d, 1.5 );\n\t\t\tfillLight1.position.set( 2, 1, 1 );\n\t\t\tscene.add( fillLight1 );\n\n\t\t\tconst directionalLight = new THREE.DirectionalLight( 0xffffff, 2.5 );\n\t\t\tdirectionalLight.position.set( - 5, 25, - 1 );\n\t\t\tdirectionalLight.castShadow = true;\n\t\t\tdirectionalLight.shadow.camera.near = 0.01;\n\t\t\tdirectionalLight.shadow.camera.far = 500;\n\t\t\tdirectionalLight.shadow.camera.right = 30;\n\t\t\tdirectionalLight.shadow.camera.left = - 30;\n\t\t\tdirectionalLight.shadow.camera.top\t= 30;\n\t\t\tdirectionalLight.shadow.camera.bottom = - 30;\n\t\t\tdirectionalLight.shadow.mapSize.width = 1024;\n\t\t\tdirectionalLight.shadow.mapSize.height = 1024;\n\t\t\tdirectionalLight.shadow.radius = 4;\n\t\t\tdirectionalLight.shadow.bias = - 0.00006;\n\t\t\tscene.add( directionalLight );\n\n\t\t\tconst container = document.getElementById( 'container' );\n\n\t\t\tconst renderer = new THREE.WebGLRenderer( { antialias: true } );\n\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t\trenderer.setAnimationLoop( animate );\n\t\t\trenderer.shadowMap.enabled = true;\n\t\t\trenderer.shadowMap.type = THREE.VSMShadowMap;\n\t\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\t\tcontainer.appendChild( renderer.domElement );\n\n\t\t\t/*\n\t\t\tconst stats = new Stats();\n\t\t\tstats.domElement.style.position = 'absolute';\n\t\t\tstats.domElement.style.top = '0px';\n\t\t\tcontainer.appendChild( stats.domElement );\n\t\t\t*/\n\n\t\t\tconst GRAVITY = 30;\n\n\t\t\tconst STEPS_PER_FRAME = 5;\n\n\t\t\tconst worldOctree = new Octree();\n\n\t\t\tconst playerCollider = new Capsule( new THREE.Vector3( 0, 0.35, 0 ), new THREE.Vector3( 0, 1, 0 ), 0.35 );\n\n\t\t\tconst playerVelocity = new THREE.Vector3();\n\t\t\tconst playerDirection = new THREE.Vector3();\n\n\t\t\tlet playerOnFloor = false;\n\t\t\tlet mouseTime = 0;\n\n\t\t\tconst keyStates = {};\n\n\t\t\tconst vector1 = new THREE.Vector3();\n\t\t\tconst vector2 = new THREE.Vector3();\n\t\t\tconst vector3 = new THREE.Vector3();\n\n\t\t\tdocument.addEventListener( 'keydown', ( event ) => {\n\n\t\t\t\tkeyStates[ event.code ] = true;\n\n\t\t\t} );\n\n\t\t\tdocument.addEventListener( 'keyup', ( event ) => {\n\n\t\t\t\tkeyStates[ event.code ] = false;\n\n\t\t\t} );\n\n\t\t\tcontainer.addEventListener( 'mousedown', () => {\n\n\t\t\t\tdocument.body.requestPointerLock();\n\n\t\t\t\tmouseTime = performance.now();\n\n\t\t\t} );\n\n\t\t\tdocument.body.addEventListener( 'mousemove', ( event ) => {\n\n\t\t\t\tif ( document.pointerLockElement === document.body ) {\n\n\t\t\t\t\tcamera.rotation.y -= event.movementX / 500;\n\t\t\t\t\tcamera.rotation.x -= event.movementY / 500;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\twindow.addEventListener( 'resize', onWindowResize );\n\n\t\t\tfunction onWindowResize() {\n\n\t\t\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\t\t}\n\n\t\t\tfunction playerCollisions() {\n\n\t\t\t\tconst result = worldOctree.capsuleIntersect( playerCollider );\n\n\t\t\t\tplayerOnFloor = false;\n\n\t\t\t\tif ( result ) {\n\n\t\t\t\t\tplayerOnFloor = result.normal.y > 0;\n\n\t\t\t\t\tif ( ! playerOnFloor ) {\n\n\t\t\t\t\t\tplayerVelocity.addScaledVector( result.normal, - result.normal.dot( playerVelocity ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( result.depth >= 1e-10 ) {\n\n\t\t\t\t\t\tplayerCollider.translate( result.normal.multiplyScalar( result.depth ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction updatePlayer( deltaTime ) {\n\n\t\t\t\tlet damping = Math.exp( - 4 * deltaTime ) - 1;\n\n\t\t\t\tif ( ! playerOnFloor ) {\n\n\t\t\t\t\tplayerVelocity.y -= GRAVITY * deltaTime;\n\n\t\t\t\t\t// small air resistance\n\t\t\t\t\tdamping *= 0.1;\n\n\t\t\t\t}\n\n\t\t\t\tplayerVelocity.addScaledVector( playerVelocity, damping );\n\n\t\t\t\tconst deltaPosition = playerVelocity.clone().multiplyScalar( deltaTime );\n\t\t\t\tplayerCollider.translate( deltaPosition );\n\n\t\t\t\tplayerCollisions();\n\n\t\t\t\tcamera.position.copy( playerCollider.end );\n\t\t\t\tconsole.log(camera.position);\n\t\t\t}\n\n\t\t\tfunction getForwardVector() {\n\n\t\t\t\tcamera.getWorldDirection( playerDirection );\n\t\t\t\tplayerDirection.y = 0;\n\t\t\t\tplayerDirection.normalize();\n\n\t\t\t\treturn playerDirection;\n\n\t\t\t}\n\n\t\t\tfunction getSideVector() {\n\n\t\t\t\tcamera.getWorldDirection( playerDirection );\n\t\t\t\tplayerDirection.y = 0;\n\t\t\t\tplayerDirection.normalize();\n\t\t\t\tplayerDirection.cross( camera.up );\n\n\t\t\t\treturn playerDirection;\n\n\t\t\t}\n\n\t\t\tfunction controls( deltaTime ) {\n\n\t\t\t\t// gives a bit of air control\n\t\t\t\tconst speedDelta = deltaTime * ( playerOnFloor ? 25 : 8 );\n\n\t\t\t\tif ( keyStates[ 'KeyW' ] ) {\n\n\t\t\t\t\tplayerVelocity.add( getForwardVector().multiplyScalar( speedDelta ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( keyStates[ 'KeyS' ] ) {\n\n\t\t\t\t\tplayerVelocity.add( getForwardVector().multiplyScalar( - speedDelta ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( keyStates[ 'KeyA' ] ) {\n\n\t\t\t\t\tplayerVelocity.add( getSideVector().multiplyScalar( - speedDelta ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( keyStates[ 'KeyD' ] ) {\n\n\t\t\t\t\tplayerVelocity.add( getSideVector().multiplyScalar( speedDelta ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( playerOnFloor ) {\n\n\t\t\t\t\tif ( keyStates[ 'Space' ] ) {\n\n\t\t\t\t\t\tplayerVelocity.y = 15;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst loader = new GLTFLoader().setPath( './models/school/' );\n\n\t\t\tloader.load( 'school.gltf', ( gltf ) => {\n\t\t\t\tgltf.scene.scale.set(10, 10, 10); \n\t\t\t\tscene.add( gltf.scene );\n\n\t\t\t\tworldOctree.fromGraphNode( gltf.scene );\n\n\t\t\t\tgltf.scene.traverse( child => {\n\n\t\t\t\t\tif ( child.isMesh ) {\n\n\t\t\t\t\t\tchild.castShadow = true;\n\t\t\t\t\t\tchild.receiveShadow = true;\n\n\t\t\t\t\t\tif ( child.material.map ) {\n\n\t\t\t\t\t\t\tchild.material.map.anisotropy = 4;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tconst helper = new OctreeHelper( worldOctree );\n\t\t\t\thelper.visible = false;\n\t\t\t\tscene.add( helper );\n\n\t\t\t\t/*\n\t\t\t\tconst gui = new GUI( { width: 200 } );\n\t\t\t\tgui.add( { debug: false }, 'debug' )\n\t\t\t\t\t.onChange( function ( value ) {\n\n\t\t\t\t\t\thelper.visible = value;\n\n\t\t\t\t\t} );*/\n\t\t\t\n\t\t\t} );\n\n\t\t\tfunction teleportPlayerIfOob() {\n\n\t\t\t\tif ( camera.position.y <= - 25 ) {\n\n\t\t\t\t\tplayerCollider.start.set( 0, 0.35, 0 );\n\t\t\t\t\tplayerCollider.end.set( 0, 1, 0 );\n\t\t\t\t\tplayerCollider.radius = 0.35;\n\t\t\t\t\tcamera.position.copy( playerCollider.end );\n\t\t\t\t\tcamera.rotation.set( 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tfunction animate() {\n\n\t\t\t\tconst deltaTime = Math.min( 0.05, clock.getDelta() ) / STEPS_PER_FRAME;\n\n\t\t\t\t// we look for collisions in substeps to mitigate the risk of\n\t\t\t\t// an object traversing another too quickly for detection.\n\n\t\t\t\tfor ( let i = 0; i < STEPS_PER_FRAME; i ++ ) {\n\n\t\t\t\t\tcontrols( deltaTime );\n\n\t\t\t\t\tupdatePlayer( deltaTime );\n\n\t\t\t\t\tteleportPlayerIfOob();\n\n\t\t\t\t}\n\n\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t//stats.update();\n\n\t\t\t}\n\n\t\t</script>\n\t</body>\n</html>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/frontend/index.html b/frontend/index.html
--- a/frontend/index.html	(revision f269d692b373464962e4efde1d0e69761ecac4ef)
+++ b/frontend/index.html	(date 1740570342939)
@@ -150,6 +150,14 @@
 
 			} );
 
+var el = document.getElementById( 'overlay' );
+
+el.addEventListener( 'click', function () {
+
+	scope.renderer.domElement.requestPointerLock();
+
+} );
+
 			window.addEventListener( 'resize', onWindowResize );
 
 			function onWindowResize() {
